######################### 7/10/2012 ##########################
//
//  Protofilament.h
//  CytoSim
//
//  Created by Garegin Papoian on 6/2/12.
//  Copyright (c) 2012 University of Maryland. All rights reserved.
//

#ifndef CytoSim_Protofilament_h
#define CytoSim_Protofilament_h

#include "Composite.h"
#include "Species.h"

namespace chem {
    
class ProtoFilament : public Composite {
private:
    SpeciesDiffusing _proto_species;
public:
    ProtoFilament(const std::string &species_name, size_t len = 0) : Composite(), _proto_species(species_name) 
    {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushBackSpeciesUnique(std::move(species));
            this->species().back()->setParent(this);
        }
    }

    virtual void growPlusEnd(size_t len) {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushBackSpeciesUnique(std::move(species));
        }
    }
    
    virtual void growMinusEnd(size_t len) {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushFrontSpeciesUnique(std::move(species));
        }
    }
    
    virtual std::string getFullName() const {
        return "ProtoFilament:[" + _proto_species.getName() + "]";
    }

};

} // end of chem


#endif
##############################################################


######################### 6/3/2012 ##########################

This code uses SFINAE to determine at compile time whether two types are the same.
However, it does not do polymorhic check, but instead literally two classes as 
they are without polymorphic conversion. Us

template<typename T1>
struct isSame {
    template<typename T2>
    bool operator() (const T2& t2, typename std::enable_if<std::is_same<T1, T2>::value>::type* p = nullptr){
        return true;
    }
    
    template<typename T2>
    bool operator() (const T2& t2, typename std::enable_if<!std::is_same<T1, T2>::value>::type* p = nullptr) 
    { 
        return false;
    }                                                            
};

and also can do the following,
---
struct isComposite {
    bool operator () (const Composite &c) {
        return typeid(c)==typeid(Composite&) ? true : false; 
        
    }
};

######################### 5/17/2012 ##########################
To run specific tests only in google test:
--gtest_filter=SpeciesDBTest.*
##############################################################

######################### 5/17/2012 ##########################
May be useful to know. Not checked if works. Can be used to 
declare save_construct_data as friend of SpeciesType.

//class SpeciesType;
//
//namespace boost { namespace serialization {
//template<class Archive>
//    inline void save_construct_data(Archive & ar, const SpeciesType * t, const unsigned int file_version);
//}}
##############################################################


######################### 5/17/2012 ##########################
Incorporating googletest framework

http://code.google.com/p/googletest/wiki/XcodeGuide

That link above is little outdated, but most information still applies. I used the svn 
checkout and then had to manually change a number of build settings so it compiles 
under XCode 4.3 and gcc 4.7. A framework was created, and examples worked fine.

To create subfolders in XCode 4.3, first created them in Finder and then added them 
to the XCode (using the Groups option instead of references folders - the latter did 
not seem to work).

There are several ways to link against gtest. At the end I linked against 
libgtest_main. For the target TestSuite, the linker search directory need to be 
specified, so libgtest_main can be found (despite gtest framework being added to 
the dependencies). Now there is no need to have a main function - we can have 
as many test files as we want, and gtest will run all of them one by one.  

##############################################################


######################### 5/17/2012 ##########################

--> These are aparently not needed

///The assignment operator, based on copy and swap idiom,
///see [Copy&Swap](@ref http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom]
SpeciesType& operator=(SpeciesType other) 
{
    swap(*this, other);
    return *this;
} 

///Swap non-member function is needed for the assignment operator
friend void swap(SpeciesType& first, SpeciesType& second) // nothrow
{
    // enable ADL (not necessary in our case, but good practice)
    using std::swap; 
    swap(first._name, second._name); 
    swap(first._type, second._type);
}

///Assignment operators copies all fields. May be needed for boost::flyweight?
SpeciesType& operator=(SpeciesType&& st){
    _name=std::move(st._name);
    _type=st._type;
    return *this;
}
##############################################################




######################### 4/22/2012 ##########################

Reaction (ARR_REAC_SPECIES &S, ARR_REAC_COEFF &c) : _id(_max_id++)
{   _S.swap(S);
    _c.swap(c);      
    std::cout << "Constructed" << std::endl;}


Species with an _id field (as shown, the class is packed into 64 bytes):

Species.h:

class Species {
private:
    std::vector<reaction_num_t> _reactants;
    std::vector<reaction_num_t> _products;
    const SpeciesType &_type;
    species_num_t _id;
    species_copy_t _n;
    static species_num_t _max_id;
public:
    Species (SpeciesType &name) : _reactants(), _products(), _type(name),_id(_max_id++), _n(0) 
    {
        //std::cout << "Species " << _id << ", Constructed" << std::endl;
    }
    Species (const Species &r) = delete;
    // Setters
    void incrementN(species_copy_t delta) {_n+=delta;}
    void setN(species_copy_t n) {_n=n;}
    // Accessors 
    species_num_t getSpecies() const {return _id;}
    species_copy_t getN() const {return _n;}
    void printSelf() const {
        std::cout << "Species: " << _type.getName() << ", ID=" << _id << std::endl;
    }
};

Species.cpp:

#include "Species.h"

species_num_t Species::_max_id=0;

############################ END ############################



######################### 3/3/2010 ##########################

Assuming Snow Leopard (Mac OS X 10.6.2 - Intel), then 'long' is 64-bits with the default compiler.

Specify 'g++ -m64' and it will likely be 64-bits on earlier versions too.

 1 = sizeof(char)
 1 = sizeof(unsigned char)
 2 = sizeof(short)
 2 = sizeof(unsigned short)
 4 = sizeof(int)
 4 = sizeof(unsigned int)
 8 = sizeof(long)
 8 = sizeof(unsigned long)
 4 = sizeof(float)
 8 = sizeof(double)
16 = sizeof(long double)
 8 = sizeof(size_t)
 8 = sizeof(ptrdiff_t)
 8 = sizeof(time_t)
 8 = sizeof(void *)
 8 = sizeof(char *)
 8 = sizeof(short *)
 8 = sizeof(int *)
 8 = sizeof(long *)
 8 = sizeof(float *)
 8 = sizeof(double *)
 8 = sizeof(int (*)(void))
 8 = sizeof(double (*)(void))
 8 = sizeof(char *(*)(void))
 
 Tested with:

i686-apple-darwin10-g++-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5646) (dot 1)
Copyright (C) 2007 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.