######################### 9/8/2012 ##########################
Benchmarking CytoSim 0.10 with a large reaction-diffusion system

%%%% Befor introducing boost::pool; signaling is turned off %%%%

const int NGRID = 50;
NUM_OF_STEP = pow(10,7);
Num of Species: 250000
Num of Reactions: 1720000

Main Elapsed for ChemNRMImpl::run(...): dt=72.9795
Main Total Elapsed for CompartmentGrid<NDIM>...: dt=87.1045

%%%% After introducing boost::pool; signaling is turned on for Reactions and off for Species %%%%
NUM_OF_STEP = pow(10,7);
Num of Species: 250000
Num of Reactions: 1720000

Main Elapsed for ChemNRMImpl::run(...): dt=61.8113
Main Total Elapsed for CompartmentGrid<NDIM>...: dt=72.5796


%%%% After reworking Reactions to a hieararchy; signaling is turned off %%%%
NUM_OF_STEP = pow(10,7);
Num of Species: 250000
Num of Reactions: 1720000

Main Elapsed for ChemNRMImpl::run(...): dt=55.3242
Main Total Elapsed for CompartmentGrid<NDIM>...: dt=65.3534


%%%% As above, but on MacbBook Pro Retina %%%%
NUM_OF_STEP = pow(10,7);
Num of Species: 250000
Num of Reactions: 1720000

Main Elapsed for ChemNRMImpl::run(...): dt=41.94436
Main Total Elapsed for CompartmentGrid<NDIM>...: dt=49.1104

##############################################################


######################### 7/14/2012 ##########################
//
//  Signaling.h
//  CytoSim
//
//  Created by Garegin Papoian on 5/13/12.
//  Copyright (c) 2012 University of Maryland. All rights reserved.
//

#ifndef CytoSim_Signaling_h
#define CytoSim_Signaling_h

#include <memory>
#include <unordered_map>
#include <functional>
#include <cassert>

#include <boost/signals2/signal.hpp>
#include <boost/signals2/connection.hpp>
#include <boost/signals2/shared_connection_block.hpp>
#include "utility.h"

namespace chem {

class RSpecies;
class Reaction;

/// This is a RSpecies signal object that will be called by ChemSignal, usually when requested by the 
/// reaction simulation algorithm
typedef boost::signals2::signal<void (RSpecies *, int)> RSpeciesCopyNChangedSignal;

/// This is a Reaction signal object that will be called by ChemSignal, usually when requested by the 
/// reaction simulation algorithm
typedef boost::signals2::signal<void (Reaction *)> ReactionEventSignal;

/// ChemSignal manages callbacks for RSpecies and Reactions objects. 

/*!  One ChemSignal should be instantiated per chemical network. RSpecies and Reactions that need to be monitored 
 *   can be made to signal, based on the boost:signal2 library. Multiple receiving slots can be connected to signals. 
 *
 *   Slots can be temporarily blocked or completely disconnected. Signals can be destroyed.
 *   Here is an example of usage:
 *   @code 
 ...
 Species* A1 = ...
 ...
 ChemSignal sm;
 A1->makeSignaling(sm);
 PrintRSpecies ps;
 ...
 std::function<void (RSpecies *, int)> psf(ps);
 boost::signals2::shared_connection_block conn_a1(sm.connect(A1, [](RSpecies *s, int i){s->printSelf();}), true);
 // or   sm.connect(A1, print_RSpecies);
 // or  sm.connect(A1, PrintRSpecies());
 // or   boost::signals2::shared_connection_block conn_a1(sm.connect(A1,psf), false);
...
// run simulation for some time
 ...
 conn_a1.block(); // this temporarily stops slots from being called.
...
 conn_a1.disconnect(); // this permanently disconnects the slot
...
 A1->stopSignaling(sm); // this destroys the Signal itself (with associated multiple slots)
...
 @endcode
 */
class ChemSignal {
private:
    std::unordered_map<RSpecies *, std::unique_ptr<RSpeciesCopyNChangedSignal>> _map_RSpecies_signal;///< Keep track of signals corresponding to various RSpecies
    std::unordered_map<Reaction *, std::unique_ptr<ReactionEventSignal>> _map_reaction_signal;///< Keep track of signals corresponding to various Reactions
private:
    /// Search the map for a signal corresponding to parameter, Reaction *r. Throw std::out_of_range exception if not found.
    std::unordered_map<Reaction *, std::unique_ptr<ReactionEventSignal>>::const_iterator 
    findSignal(Reaction *r) const {
        auto sig_it = _map_reaction_signal.find(r);
        if(sig_it==_map_reaction_signal.end())
            throw std::out_of_range("ChemSignal::findSignal(Reaction *r) key error...");
        return sig_it;
    }
    
    /// Search the map for a signal corresponding to parameter, RSpecies *s. Throw std::out_of_range exception if not found.
    std::unordered_map<RSpecies *, std::unique_ptr<RSpeciesCopyNChangedSignal>>::const_iterator 
    findSignal(RSpecies *s) const {
        auto sig_it = _map_RSpecies_signal.find(s);
        if(sig_it==_map_RSpecies_signal.end())
            throw std::out_of_range("ChemSignal::findSignal(RSpecies *s) key error...");
        return sig_it;
    }
    
    /// Assert that a signal corresponding to Reaction *r does not exist or throw std::runtime_error.
    void assertSignalDoesNotExist (Reaction *r){
        auto sig_it = _map_reaction_signal.find(r);
        if(sig_it!=_map_reaction_signal.end())
            throw std::runtime_error("ChemSignal::assertSignalDoesNotExist (Reaction *r) Reaction already present in the map...");
    }
    
    /// Assert that a signal corresponding to RSpecies *s does not exist or throw std::runtime_error.
    void assertSignalDoesNotExist (RSpecies *s){
        auto sig_it = _map_RSpecies_signal.find(s);
        if(sig_it!=_map_RSpecies_signal.end())
            throw std::runtime_error("ChemSignal::assertSignalDoesNotExist (RSpecies *s) RSpecies already present in the map...");
    }

public:
    /// Broadcasts signal corresponding to Reaction *r. If the Reaction is not found, std::out_of_range exception will be thrown.
    /// This method is usally only called by the Gillespie-like algorithm, and not the outside code.
    void emitReactionSignal(Reaction *r) const {
        auto sig_it = findSignal(r);
        (*sig_it->second)(r);
    }
    
    /// Broadcasts signal corresponding to RSpecies *s. If the Specis is not found, std::out_of_range exception will be thrown.
    /// This method is usally only called by the Gillespie-like algorithm, and not the outside code.
    void emitRSpeciesSignal(RSpecies *s, int delta) const {
        auto sig_it = findSignal(s);
        (*sig_it->second)(s,delta);
    }
    
    /// Inserts a signal corresponding to RSpecies *s into the map. Should only be called by the RSpecies class.
    /// @note other classes should instead call void RSpecies::makeSignaling(ChemSignal &sm);
    void addSignalingRSpecies(RSpecies *s){
        assertSignalDoesNotExist(s);
        _map_RSpecies_signal.emplace(s,make_unique<RSpeciesCopyNChangedSignal>());
    }

    
    /// Inserts a signal corresponding to Reaction *r into the map. Should only be called by the Reaction class.
    /// @note other classes should instead call void Reaction::makeSignaling(ChemSignal &sm);
    void addSignalingReaction (Reaction *r){
        assertSignalDoesNotExist(r);
        _map_reaction_signal.emplace(r,make_unique<ReactionEventSignal>());
    }
    
    /// Connect the callback, react_callback to a signal corresponding to Reaction *r.
    /// @param Reaction *r - the signal will correspond to this Reaction
    /// @param std::function<void (Reaction *)> const &react_callback - a function object to be called (a slot)
    /// @param int priority - lower priority slots will be called first. Default is 5 Do not use priorities 1 and 2 
    ///                       unless absolutely essential.
    boost::signals2::connection connect(Reaction *r, std::function<void (Reaction *)> const &react_callback, int priority=5) {
        auto sig_it = findSignal(r);
        return sig_it->second->connect(priority, react_callback);
    }

    /// Connect the callback, RSpecies_callback to a signal corresponding to RSpecies *s.
    /// @param RSpecies *s - the signal will correspond to this RSpecies
    /// @param std::function<void (RSpecies *, int)> const &RSpecies_callback - a function object to be called (a slot). 
    ///        int here corresponds to delta, the change in copy number of the RSpecies (for which the signal was emitted)
    /// @param int priority - lower priority slots will be called first. Default is 5 Do not use priorities 1 and 2 
    ///                       unless absolutely essential.
    boost::signals2::connection connect(Species *s, std::function<void (RSpecies *, int)> const &RSpecies_callback, int priority=5) {
        RSpecies *rs = &s->getRSpecies();
        auto sig_it = findSignal(rs);
        return sig_it->second->connect(priority, RSpecies_callback);
    }
    
    /// Destroy signal corresponding to Reaction r. Should only be used by the Reaction class.
    /// @note   Other classes should instead call void Reaction::stopSignaling (ChemSignal &sm);
    void disconnect(Reaction *r){
        auto sig_it = findSignal(r);
        _map_reaction_signal.erase(sig_it);
    }

    /// Destroy signal corresponding to Reaction r. Should only be used by the RSpecies class.
    /// @note   Other classes should instead call void RSpecies::stopSignaling (ChemSignal &sm);
    void disconnect(RSpecies *s){
        auto sig_it = findSignal(s);
        _map_RSpecies_signal.erase(sig_it);
    }
};

} //end of namespace 
#endif

##############################################################

######################### 7/10/2012 ##########################
from class Composite:

    std::deque<std::unique_ptr<Species>> _species;
    
        void pushBackSpeciesUnique(std::unique_ptr<Species> &&child_species) {
        _species.push_back(std::move(child_species));
        _species.back()->setParent(this);
    }
    
    template<typename T, typename ...Args>
    void pushBackSpecies( Args&& ...args )
    {
        _species.push_back(std::unique_ptr<T>( new T( std::forward<Args>(args)...) ));
        _species.back()->setParent(this);
        //        _species.emplace_back(make_unique(Args...));
    }
    
    void pushFrontSpeciesUnique(std::unique_ptr<Species> &&child_species) {
        _species.push_front(std::move(child_species));
        _species.front()->setParent(this);
    }
    
    template<typename T, typename ...Args>
    void pushFrontSpecies( Args&& ...args )
    {
        _species.push_front(std::unique_ptr<T>( new T( std::forward<Args>(args)...) ));
        _species.front()->setParent(this);
        //        _species.emplace_front(make_unique(Args...));
    }
    
        virtual std::deque<std::unique_ptr<Species>>& species() {
        return _species;
    }
    
    virtual const std::deque<std::unique_ptr<Species>> & species() const {
        return _species;
    }
    
    virtual size_t countSpecies() const {
        size_t res = species().size();
        for(auto &c : _children)
            res+=c->countSpecies();
        return res;
    }

    virtual Species* species(size_t i) {return _species[i].get();}

##############################################################


######################### 7/10/2012 ##########################
//
//  Protofilament.h
//  CytoSim
//
//  Created by Garegin Papoian on 6/2/12.
//  Copyright (c) 2012 University of Maryland. All rights reserved.
//

#ifndef CytoSim_Protofilament_h
#define CytoSim_Protofilament_h

#include "Composite.h"
#include "Species.h"

namespace chem {
    
class ProtoFilament : public Composite {
private:
    SpeciesDiffusing _proto_species;
public:
    ProtoFilament(const std::string &species_name, size_t len = 0) : Composite(), _proto_species(species_name) 
    {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushBackSpeciesUnique(std::move(species));
            this->species().back()->setParent(this);
        }
    }

    virtual void growPlusEnd(size_t len) {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushBackSpeciesUnique(std::move(species));
        }
    }
    
    virtual void growMinusEnd(size_t len) {
        for(size_t i=0; i<len; ++i){
            auto species = std::unique_ptr<SpeciesDiffusing>(new SpeciesDiffusing(_proto_species));
            pushFrontSpeciesUnique(std::move(species));
        }
    }
    
    virtual std::string getFullName() const {
        return "ProtoFilament:[" + _proto_species.getName() + "]";
    }

};

} // end of chem


#endif
##############################################################


######################### 6/3/2012 ##########################

This code uses SFINAE to determine at compile time whether two types are the same.
However, it does not do polymorhic check, but instead literally two classes as 
they are without polymorphic conversion. Us

template<typename T1>
struct isSame {
    template<typename T2>
    bool operator() (const T2& t2, typename std::enable_if<std::is_same<T1, T2>::value>::type* p = nullptr){
        return true;
    }
    
    template<typename T2>
    bool operator() (const T2& t2, typename std::enable_if<!std::is_same<T1, T2>::value>::type* p = nullptr) 
    { 
        return false;
    }                                                            
};

and also can do the following,
---
struct isComposite {
    bool operator () (const Composite &c) {
        return typeid(c)==typeid(Composite&) ? true : false; 
        
    }
};

######################### 5/17/2012 ##########################
To run specific tests only in google test:
--gtest_filter=SpeciesDBTest.*
##############################################################

######################### 5/17/2012 ##########################
May be useful to know. Not checked if works. Can be used to 
declare save_construct_data as friend of SpeciesType.

//class SpeciesType;
//
//namespace boost { namespace serialization {
//template<class Archive>
//    inline void save_construct_data(Archive & ar, const SpeciesType * t, const unsigned int file_version);
//}}
##############################################################


######################### 5/17/2012 ##########################
Incorporating googletest framework

http://code.google.com/p/googletest/wiki/XcodeGuide

That link above is little outdated, but most information still applies. I used the svn 
checkout and then had to manually change a number of build settings so it compiles 
under XCode 4.3 and gcc 4.7. A framework was created, and examples worked fine.

To create subfolders in XCode 4.3, first created them in Finder and then added them 
to the XCode (using the Groups option instead of references folders - the latter did 
not seem to work).

There are several ways to link against gtest. At the end I linked against 
libgtest_main. For the target TestSuite, the linker search directory need to be 
specified, so libgtest_main can be found (despite gtest framework being added to 
the dependencies). Now there is no need to have a main function - we can have 
as many test files as we want, and gtest will run all of them one by one.  

##############################################################


######################### 5/17/2012 ##########################

--> These are aparently not needed

///The assignment operator, based on copy and swap idiom,
///see [Copy&Swap](@ref http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom]
SpeciesType& operator=(SpeciesType other) 
{
    swap(*this, other);
    return *this;
} 

///Swap non-member function is needed for the assignment operator
friend void swap(SpeciesType& first, SpeciesType& second) // nothrow
{
    // enable ADL (not necessary in our case, but good practice)
    using std::swap; 
    swap(first._name, second._name); 
    swap(first._type, second._type);
}

///Assignment operators copies all fields. May be needed for boost::flyweight?
SpeciesType& operator=(SpeciesType&& st){
    _name=std::move(st._name);
    _type=st._type;
    return *this;
}
##############################################################




######################### 4/22/2012 ##########################

Reaction (ARR_REAC_SPECIES &S, ARR_REAC_COEFF &c) : _id(_max_id++)
{   _S.swap(S);
    _c.swap(c);      
    std::cout << "Constructed" << std::endl;}


Species with an _id field (as shown, the class is packed into 64 bytes):

Species.h:

class Species {
private:
    std::vector<reaction_num_t> _reactants;
    std::vector<reaction_num_t> _products;
    const SpeciesType &_type;
    species_num_t _id;
    species_copy_t _n;
    static species_num_t _max_id;
public:
    Species (SpeciesType &name) : _reactants(), _products(), _type(name),_id(_max_id++), _n(0) 
    {
        //std::cout << "Species " << _id << ", Constructed" << std::endl;
    }
    Species (const Species &r) = delete;
    // Setters
    void incrementN(species_copy_t delta) {_n+=delta;}
    void setN(species_copy_t n) {_n=n;}
    // Accessors 
    species_num_t getSpecies() const {return _id;}
    species_copy_t getN() const {return _n;}
    void printSelf() const {
        std::cout << "Species: " << _type.getName() << ", ID=" << _id << std::endl;
    }
};

Species.cpp:

#include "Species.h"

species_num_t Species::_max_id=0;

############################ END ############################



######################### 3/3/2010 ##########################

Assuming Snow Leopard (Mac OS X 10.6.2 - Intel), then 'long' is 64-bits with the default compiler.

Specify 'g++ -m64' and it will likely be 64-bits on earlier versions too.

 1 = sizeof(char)
 1 = sizeof(unsigned char)
 2 = sizeof(short)
 2 = sizeof(unsigned short)
 4 = sizeof(int)
 4 = sizeof(unsigned int)
 8 = sizeof(long)
 8 = sizeof(unsigned long)
 4 = sizeof(float)
 8 = sizeof(double)
16 = sizeof(long double)
 8 = sizeof(size_t)
 8 = sizeof(ptrdiff_t)
 8 = sizeof(time_t)
 8 = sizeof(void *)
 8 = sizeof(char *)
 8 = sizeof(short *)
 8 = sizeof(int *)
 8 = sizeof(long *)
 8 = sizeof(float *)
 8 = sizeof(double *)
 8 = sizeof(int (*)(void))
 8 = sizeof(double (*)(void))
 8 = sizeof(char *(*)(void))
 
 Tested with:

i686-apple-darwin10-g++-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5646) (dot 1)
Copyright (C) 2007 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.