//
//  SpeciesType.h
//  CytoSim
//
//  Created by Garegin Papoian on 5/17/12.
//  Copyright (c) 2012 University of Maryland. All rights reserved.
//

#ifndef CytoSim_SpeciesType_h
#define CytoSim_SpeciesType_h

#include <boost/flyweight.hpp>

enum class SType : unsigned char {
    Bulk = 0, ///< Species that have no spatial association (i.e. are "well-mixed") 
    Diffusing = 1, ///< Species that diffuse between cytosolic compartments 
    Membrane = 2, ///< Species that diffuse within a membrane 
    Filament=3, ///< Species that comprise filaments (such as F-Actin)
    Walking=4, ///< Species that can walk ("convectively") on filaments (like Myosin X)
    Motors=5 ///< Species that bind to filaments and generate forces (like Myosin II)
    };
    
    
    /// SpeciesType class represents the type of chemical Species (for example, a Species with name "Arp2/3" and SType Diffusing)
    
    /*! This class describes the type of Species. The description is based on a name (std::string) and SType (Bulk, Diffusing, etc.). 
     *  @note In the future may implement the Logging and Persistence interfaces. 
     *  @note SpeciesType is used by Species with the flyweight pattern, since in a large system millions of unique Species may exist,
     *        but only a handful of SpeciesType objects. For example: one ("F-Actin",Filament) may correspond to millions of individual 
     *        Species.
     */
    class SpeciesType {
    private:
        std::string _name; ///< the descriptive name associated with this Species 
        SType _type; ///< the type of species, such as Bulk, Diffusing, etc.
        static std::vector<std::string> _vec_type_name; ///< this variable is used to help translate strings to enum values for the SType
    public:
        ///Given a species name as a string and its SType, constructs the SpeciesType
        SpeciesType(const std::string &name, SType type) : _name(name), _type(type) {}
        
        ///Given a species name as a string and its type as a string, constructs the SpeciesType
        SpeciesType(const SpeciesType &st) : _name(st._name), _type(st._type) {}
        
        ///The move constructor. May be needed for boost::flyweight?
        SpeciesType(SpeciesType &&st) : _name(std::move(st._name)), _type(st._type) {}

        ///Swap non-member function is needed for the implicit assignment operator
        void swap(SpeciesType &other)
        {   
            std::cout << "SpeciesType::swap(...) was called" << std::endl; 
            _name.swap(other._name);
            std::swap(_type,other._type);
        }
        
        ///The lvalue assignment operator
        SpeciesType& operator=(const SpeciesType &other) 
        {
            _name = other._name;
            _type = other._type;
            return *this;
        } 
        
        ///Move assignment operator. 
        SpeciesType& operator=(SpeciesType&& st){
            _name=std::move(st._name);
            _type=st._type;
            return *this;
        }
                
        ///Equality operator use both species name and type to compare to SpeciesType objects
        bool operator==(const SpeciesType& species_type) const 
        {
            return species_type.getName()==_name && species_type.getType()==_type;
        }
        
        ///Inequality operator use both species name and type to compare to SpeciesType objects
        bool operator!=(const SpeciesType& species_type) const 
        {
            return !(species_type==(*this));
        }
        
        ///Returns the name associated with this SpeciesType as a string
        std::string getName() const {return _name;}
        
        
        ///Returns the SType associated with this SpeciesType 
        SType getType() const {return _type;}
        
        ///Returns a string representing this SpeciesType by concatanating its name and type 
        std::string getTypeAsString () const {return _vec_type_name[static_cast<int>(_type)];}
        
        ///Return if true if this SpeciesType has name and SType given as parameters to this function 
        bool is_of_type(const std::string &name, SType type) const {return name==_name && type==_type;}
        
        ///boost::flyweight needs a hashing function, defined here.
        friend std::size_t hash_value(SpeciesType const& species_type){
            std::size_t seed = 0;
            int type=static_cast<int>(species_type.getType());
            boost::hash_combine(seed,species_type.getName());
            boost::hash_combine(seed,type);
            //        std::cout << species_type.getName()+"[" + species_type.getTypeAsString() << "] hash_value called...\n";
            return seed;
        }
        
        friend std::ostream& operator<<(std::ostream& os, const SpeciesType& st){
            os << st.getName() << "[" << st.getTypeAsString() << "]";
            return os;
        }
        
//        friend istream& operator>>(istream& is, SpeciesType& st) 
//        { 
//            string temp; 
//            is >> temp; 
//            st.set(temp); 
//            return is; 
//        }
    };
#endif




######################### 5/17/2012 ##########################
Incorporating googletest framework

http://code.google.com/p/googletest/wiki/XcodeGuide

That link above is little outdated, but most information still applies. I used the svn 
checkout and then had to manually change a number of build settings so it compiles 
under XCode 4.3 and gcc 4.7. A framework was created, and examples worked fine.

To create subfolders in XCode 4.3, first created them in Finder and then added them 
to the XCode (using the Groups option instead of references folders - the latter did 
not seem to work).

There are several ways to link against gtest. At the end I linked against 
libgtest_main. For the target TestSuite, the linker search directory need to be 
specified, so libgtest_main can be found (despite gtest framework being added to 
the dependencies). Now there is no need to have a main function - we can have 
as many test files as we want, and gtest will run all of them one by one.  

##############################################################


######################### 5/17/2012 ##########################

--> These are aparently not needed

///The assignment operator, based on copy and swap idiom,
///see [Copy&Swap](@ref http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom]
SpeciesType& operator=(SpeciesType other) 
{
    swap(*this, other);
    return *this;
} 

///Swap non-member function is needed for the assignment operator
friend void swap(SpeciesType& first, SpeciesType& second) // nothrow
{
    // enable ADL (not necessary in our case, but good practice)
    using std::swap; 
    swap(first._name, second._name); 
    swap(first._type, second._type);
}

///Assignment operators copies all fields. May be needed for boost::flyweight?
SpeciesType& operator=(SpeciesType&& st){
    _name=std::move(st._name);
    _type=st._type;
    return *this;
}
##############################################################




######################### 4/22/2012 ##########################

Reaction (ARR_REAC_SPECIES &S, ARR_REAC_COEFF &c) : _id(_max_id++)
{   _S.swap(S);
    _c.swap(c);      
    std::cout << "Constructed" << std::endl;}


Species with an _id field (as shown, the class is packed into 64 bytes):

Species.h:

class Species {
private:
    std::vector<reaction_num_t> _reactants;
    std::vector<reaction_num_t> _products;
    const SpeciesType &_type;
    species_num_t _id;
    species_copy_t _n;
    static species_num_t _max_id;
public:
    Species (SpeciesType &name) : _reactants(), _products(), _type(name),_id(_max_id++), _n(0) 
    {
        //std::cout << "Species " << _id << ", Constructed" << std::endl;
    }
    Species (const Species &r) = delete;
    // Setters
    void incrementN(species_copy_t delta) {_n+=delta;}
    void setN(species_copy_t n) {_n=n;}
    // Accessors 
    species_num_t getSpecies() const {return _id;}
    species_copy_t getN() const {return _n;}
    void printSelf() const {
        std::cout << "Species: " << _type.getName() << ", ID=" << _id << std::endl;
    }
};

Species.cpp:

#include "Species.h"

species_num_t Species::_max_id=0;

############################ END ############################



######################### 3/3/2010 ##########################

Assuming Snow Leopard (Mac OS X 10.6.2 - Intel), then 'long' is 64-bits with the default compiler.

Specify 'g++ -m64' and it will likely be 64-bits on earlier versions too.

 1 = sizeof(char)
 1 = sizeof(unsigned char)
 2 = sizeof(short)
 2 = sizeof(unsigned short)
 4 = sizeof(int)
 4 = sizeof(unsigned int)
 8 = sizeof(long)
 8 = sizeof(unsigned long)
 4 = sizeof(float)
 8 = sizeof(double)
16 = sizeof(long double)
 8 = sizeof(size_t)
 8 = sizeof(ptrdiff_t)
 8 = sizeof(time_t)
 8 = sizeof(void *)
 8 = sizeof(char *)
 8 = sizeof(short *)
 8 = sizeof(int *)
 8 = sizeof(long *)
 8 = sizeof(float *)
 8 = sizeof(double *)
 8 = sizeof(int (*)(void))
 8 = sizeof(double (*)(void))
 8 = sizeof(char *(*)(void))
 
 Tested with:

i686-apple-darwin10-g++-4.2.1 (GCC) 4.2.1 (Apple Inc. build 5646) (dot 1)
Copyright (C) 2007 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.